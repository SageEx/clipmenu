#!/bin/bash

cache_dir=/tmp/clipmenu.$USER/

# It's ok that this only applies to the final directory.
# shellcheck disable=SC2174
mkdir -p -m0700 "$cache_dir"

declare -A last_data
declare -A last_filename

has_xsel=$(type -p xsel >/dev/null 2>&1; ! (( $? )))

while sleep "${CLIPMENUD_SLEEP:-0.5}"; do
    for selection in clipboard primary; do
        if (( has_xsel )); then
            data=$(xsel --"$selection"; printf x)
        else
            data=$(xclip -o -sel "$selection"; printf x)
        fi

        # We add and remove the x so that trailing newlines are not stripped.
        # Otherwise, they would be stripped by the very nature of how POSIX
        # defines command substitution.
        data=${data%x}

        [[ $data == *[^[:blank:]]* ]] || continue

        [[ ${last_data[$selection]} == "$data" ]] && continue

        # If we were in the middle of doing a selection when the previous poll
        # ran, then we may have got a partial clip.
        possible_partial=${last_data[$selection]}
        if [[ $possible_partial && $data == "$possible_partial"* ]]; then
            rm -- "${last_filename[$selection]}"
        fi

        # Take ownership of the clipboard, in case the original application is
        # unable to serve the clipboard request (due to being suspended, etc).
        #
        # Primary is excluded from the change of ownership as applications
        # sometimes act up if clipboard focus is taken away from them -- for
        # example, urxvt will unhilight text, which is undesirable.
        if [[ $selection != primary ]]; then
            if (( has_xsel )); then
                xsel --"$selection" | xsel -i --"$selection"
            else
                xclip -o -sel "$selection" | xclip -i -sel "$selection"
            fi
        fi

        filename="$cache_dir/$(LC_ALL=C date +%F-%T.%N)"

        last_data[$selection]=$data
        last_filename[$selection]=$filename

        if [[ $selection == primary ]] &&
           [[ ${last_data[clipboard]} == "$data" ]]; then
           # This happens with tools like autocutsel -- both selections get the
           # same data. Now that we don't use MD5s in the filenames, we need to
           # manually dedupe these.
           continue
        fi

        printf '%s' "$data" > "$filename"
    done
done
